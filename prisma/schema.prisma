generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id          String   @id @default(uuid())
  createdAt   DateTime @default(now())
  displayName String?

  identities   UserIdentity[]
  catches      Catch[]

  // Opposite side of Spawn.caughtByUser
  caughtSpawns Spawn[] @relation("CaughtSpawns")
}

model UserIdentity {
  id             String   @id @default(uuid())
  userId         String
  platform       String   // "kick" now, "discord" later
  platformUserId String?
  handle         String
  createdAt      DateTime @default(now())

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([platform, handle])
}

model Spawn {
  id        String   @id @default(uuid())

  // What chat guesses (keep this)
  pokemon   String

  // NEW: stable dex id (e.g. "pikachu") for battles/logic
  pokemonId String?

  tier      String   // common | uncommon | rare | epic | legendary
  isShiny   Boolean  @default(false)

  // NEW: random level spawns
  level     Int      @default(5)

  // NEW: base catch rate (from species)
  catchRate Int      @default(45)

  // NEW: precomputed stats + moves for this spawn (so battles donâ€™t need recompute)
  statsJson Json?
  movesJson Json?

  spawnedAt DateTime @default(now())
  expiresAt DateTime

  // When a spawn expires without being caught, we announce a "ran away" message once.
  // This flag makes the announcement idempotent across Railway restarts.
  despawnAnnounced Boolean @default(false)

  caughtAt  DateTime?
  caughtBy  String?

  // MUST have relation name that matches User.caughtSpawns
  caughtByUser User? @relation("CaughtSpawns", fields: [caughtBy], references: [id])

  catches Catch[]
}

model Catch {
  id           String   @id @default(uuid())
  userId       String
  spawnId      String

  pokemon      String
  tier         String
  isShiny      Boolean  @default(false)

  // NEW (optional but recommended): store the level that was caught
  level        Int?     

  // Seasonal leaderboard support (weekly seasons). The active season is tracked
  // in Setting: season_id / season_started_at
  season       Int      @default(1)

  pointsEarned Int
  speedMs      Int
  caughtAt     DateTime @default(now())

  user  User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  spawn Spawn @relation(fields: [spawnId], references: [id], onDelete: Cascade)

  @@index([caughtAt])
  @@index([userId, caughtAt])
  @@index([season, caughtAt])
}

model Setting {
  key       String   @id
  value     String
  updatedAt DateTime @updatedAt
}
